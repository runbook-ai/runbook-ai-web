import { loadSettings } from './settings.js';

const EXTENSION_ID = 'kjbhngehjkiiecaflccjenmoccielojj';
import { logMessage, logSystem, showProcessing, hideProcessing } from './ui.js';
import { sendDiscordMessage, triggerTyping, openDMChannel } from './discord.js';

/**
 * Handle an incoming Discord MESSAGE_CREATE event.
 * All responses are generated by the Runbook AI extension via runHeadlessTask.
 *
 * @param {object} msg       - Discord message object from the Gateway
 * @param {string} botUserId - The bot's own user ID (to skip self-messages)
 */
export async function handleMessageCreate(msg, botUserId) {
  // Only respond to direct messages.
  if (msg.guild_id) return;
  if (msg.author?.id === botUserId) return;
  if (msg.author?.bot) return;

  // Empty content means MESSAGE_CONTENT intent is not enabled.
  if (!msg.content?.trim()) {
    logSystem(
      'Received a message with empty content. ' +
      'Enable the MESSAGE_CONTENT privileged intent in your Discord application settings ' +
      '(discord.com/developers ? Your App ? Bot ? Privileged Gateway Intents).',
      'error-msg'
    );
    return;
  }

  logMessage(msg, 'incoming');

  const s = loadSettings();

  // Open (or fetch) the DM channel via REST so we get an ID that works for
  // REST API calls. The channel_id from the Gateway event sometimes causes
  // 403 40333 if the DM channel hasn't been registered with the REST session.
  let channelId = msg.channel_id;
  try {
    channelId = await openDMChannel(msg.author.id, s.botToken);
    console.log('[dm] openDMChannel resolved to', channelId, '(gateway was', msg.channel_id, ')');
  } catch (e) {
    console.warn('[dm] openDMChannel failed:', e.message, '- falling back to gateway channel_id');
    logSystem(`Could not open DM channel: ${e.message}`, 'error-msg');
  }

  // !run <runbook-name> [extra prompt text]
  const runMatch = msg.content.match(/^!run\s+(\S+)(.*)?$/i);
  if (runMatch) {
    await handleRunCommand(msg, channelId, runMatch[1].trim(), (runMatch[2] ?? '').trim(), s);
    return;
  }

  // !help
  if (/^!help\s*$/i.test(msg.content)) {
    const help =
      'Send me a message and I\'ll run it as a task.\n' +
      '`!run <runbook>` - launch a saved runbook\n' +
      '`!help` - show this message';
    await sendDiscordMessage(channelId, help, s.botToken);
    logMessage({ channel_id: channelId, content: help }, 'outgoing');
    return;
  }

  // Free-form message - delegate to the Runbook AI extension.
  showProcessing(channelId);
  triggerTyping(channelId, s.botToken);
  await runViaExtension(msg, channelId, msg.content, {}, s);
}

/**
 * Handle the `!run <runbook-name>` command.
 * Loads the runbook files and delegates execution to the Runbook AI extension.
 */
async function handleRunCommand(msg, channelId, runbookName, extraPrompt, s) {
  showProcessing(channelId);
  try {
    const [mdRes, jsonRes] = await Promise.all([
      fetch(`/runbooks/${runbookName}.md`),
      fetch(`/runbooks/${runbookName}.json`),
    ]);

    if (!mdRes.ok) {
      throw new Error(`Unknown runbook "${runbookName}". Try: craigslist-car-listings`);
    }

    const prompt = (extraPrompt ? `${extraPrompt}\n\n` : '') + await mdRes.text();
    const config = jsonRes.ok ? JSON.parse(await jsonRes.text()) : {};
    hideProcessing();

    await runViaExtension(msg, channelId, prompt, config, s);
  } catch (err) {
    hideProcessing();
    logSystem(err.message, 'error-msg');
    try { await sendDiscordMessage(channelId, `Error: ${err.message}`, s.botToken); } catch {}
  }
}

/**
 * Send a prompt + config to the Runbook AI extension via chrome.runtime.sendMessage,
 * mirroring the startRunbook() pattern from the root index.html.
 * Notifies the Discord channel with the outcome.
 */
async function runViaExtension(msg, channelId, prompt, config, s) {
  console.log('[ext] chrome.runtime available:', typeof chrome !== 'undefined' && !!chrome.runtime);
  try {
    if (typeof chrome === 'undefined' || !chrome.runtime) {
      throw new Error('chrome.runtime not available on this page');
    }

    const openResp = await chrome.runtime.sendMessage(EXTENSION_ID, { action: 'openSidePanel' });
    console.log('[ext] openSidePanel response:', openResp);
    if (openResp?.error) throw new Error(openResp.message || openResp.error);

    await new Promise(r => setTimeout(r, 500));

    const configResp = await chrome.runtime.sendMessage(EXTENSION_ID, {
      action: 'setRemoteConfig',
      args:   { config },
    });
    console.log('[ext] setRemoteConfig response:', configResp);
    if (configResp?.error) throw new Error(configResp.message || configResp.error);

    const taskResp = await chrome.runtime.sendMessage(EXTENSION_ID, {
      action: 'runHeadlessTask',
      args:   { prompt },
    });
    console.log('[ext] runHeadlessTask response:', taskResp);

    hideProcessing();

    if (taskResp?.error) {
      throw new Error(taskResp.message || taskResp.error);
    }

    const reply = taskResp?.taskResult?.result || 'Task completed with no result.';
    await sendDiscordMessage(channelId, reply, s.botToken);
    logMessage({ channel_id: channelId, content: reply }, 'outgoing');

  } catch (err) {
    console.error('[ext] runViaExtension failed:', err);
    hideProcessing();
    const errText = err?.message ?? String(err);
    const notice =
      `Extension error: ${errText}\n\n` +
      'Make sure the Runbook AI extension is installed and this page is open in Chrome.';
    await sendDiscordMessage(channelId, notice, s.botToken).catch(() => {});
    logMessage({ channel_id: channelId, content: notice }, 'outgoing');
  }
}
